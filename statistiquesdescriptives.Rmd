---
title: "Masther Thesis HALAS"
author: "ASSOUMA ALASSANE Hariph"
date: "2025-03-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
install.packages("forecast")


```


```{r}

# Charger les packages apr√®s l'installation
library(dtplyr)
library(tidyverse)
library(lubridate)
library(haven)
library(plm)
library(stargazer)
library(plot3D)
library(plotrix)
library(ggplot2)
library(viridis)
library(lmtest)    # Pour les tests statistiques
library(sandwich)  # Pour corriger l'h√©t√©rosc√©dasticit√©
library(knitr)       # Alternative pour affichage propre
library(kableExtra)  # Pour styliser le tableau

```



```{r}
# Charger la base HALASdata.dta
data <- read_dta("C:/Users/HP/OneDrive/Bureau/HALAS Master Thesis/Data/HALASdata.dta")
```

```{r}
# V√©rification des valeurs manquantes
summary(data)
```
```{r}
str(data)
```
```{r}
sapply(data, function(x) sum(is.na(x)))
```

```{r}
# S√©lection des variables principales et retard√©es
vars <- c("error", "AQI", "NO2", "PM10", "PM2_5", "SO2",
          "NO2_lag1", "PM10_lag1", "PM2_5_lag1", "SO2_lag1",
          "NO2_week", "PM10_week", "PM2_5_week", "SO2_week",
          "NO2_2weeks", "PM10_2weeks", "PM2_5_2weeks", "SO2_2weeks",
          "gdp", "inflation_rate", "unemployment_rate")

# Filtrage des colonnes souhait√©es
data_subset <- data %>%
  select(all_of(vars))  # S√©lectionne uniquement ces colonnes

# Cr√©ation d'un tableau descriptif
summary_table <- data_subset %>%
  summarise_all(list(
    Moyenne = mean, 
    M√©diane = median, 
    Ecart_Type = sd, 
    Min = min, 
    Max = max, 
    Obs = ~sum(!is.na(.))
  ))

# Affichage avec kable
summary_table %>%
  t() %>%  # Transpose le tableau pour meilleure lisibilit√©
  as.data.frame() %>%
  kable(format = "html", digits = 2, caption = "Tableau des Statistiques Descriptives") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

```
```{r}

```

```{r}
# V√©rifier le nombre de valeurs NA dans chaque colonne
colSums(is.na(data))


```

```{r}
# Agr√©ger l'AQI par pays
aqi_par_pays <- data %>%
  group_by(country, country_name) %>%
  summarize(
    mean_AQI = mean(AQI, na.rm = TRUE),
    median_AQI = median(AQI, na.rm = TRUE),
    nb_obs = n()
  )

# Afficher le tableau agr√©g√©
print(aqi_par_pays)
```

```{r}
# Convertir la variable date (en supposant qu'elle est au format Stata %td)
data <- data %>%
  mutate(date = as.Date(date, origin = "1960-01-01"),
         year = year(date))

```

```{r}

```

```{r}
library(dplyr)
library(tidyr)
library(ggplot2)

# 1. Aggregate pollutants and AQI by year
yearly_pollutants <- data %>%
  group_by(year) %>%
  summarize(
    mean_NO2   = mean(NO2, na.rm = TRUE),
    mean_PM10  = mean(PM10, na.rm = TRUE),
    mean_SO2   = mean(SO2, na.rm = TRUE),
    mean_PM2_5 = mean(PM2_5, na.rm = TRUE),
    mean_AQI   = mean(AQI, na.rm = TRUE)
  )

# 2. Reshape to long format for plotting
yearly_pollutants_long <- yearly_pollutants %>%
  pivot_longer(
    cols = starts_with("mean_"),
    names_to = "pollutant",
    values_to = "mean_value"
  ) %>%
  mutate(
    pollutant = dplyr::recode(pollutant,
                              "mean_NO2"   = "NO2",
                              "mean_PM10"  = "PM10",
                              "mean_SO2"   = "SO2",
                              "mean_PM2_5" = "PM2.5",
                              "mean_AQI"   = "AQI")
  )

# 3. Plot the trends using ggplot2
ggplot(yearly_pollutants_long,
       aes(x = factor(year), y = mean_value, group = pollutant, color = pollutant)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  labs(title = "Annual Trends in Average Pollution Levels",
       x = "Year",
       y = "Average Concentration (¬µg/m¬≥)",
       color = "Pollutants") +
  theme_minimal(base_size = 14) +
  scale_color_manual(values = c("NO2" = "blue", "PM10" = "red", "SO2" = "green",
                                "PM2.5" = "purple", "AQI" = "orange"))

```
```{r}
# Filtrer pour les pays d'int√©r√™t (codes ISO : FR, DE, GB, CH)
countries_interest <- c("FR", "DE", "GB", "CH")
data_filtered <- data %>% filter(country %in% countries_interest)

# Agr√©ger les polluants par pays et par ann√©e en calculant la moyenne
yearly_pollutants <- data_filtered %>% 
  group_by(country, year) %>% 
  summarize(
    mean_NO2   = mean(NO2, na.rm = TRUE),
    mean_PM10  = mean(PM10, na.rm = TRUE),
    mean_SO2   = mean(SO2, na.rm = TRUE),
    mean_PM2_5 = mean(PM2_5, na.rm = TRUE)
  ) %>% 
  ungroup()

# Transformer les donn√©es en format long
yearly_pollutants_long <- yearly_pollutants %>%
  pivot_longer(
    cols = starts_with("mean_"),
    names_to = "polluant",
    values_to = "mean_value"
  ) %>%
  mutate(
    polluant = dplyr::recode(polluant,
                             "mean_NO2"   = "NO2",
                             "mean_PM10"  = "PM10",
                             "mean_SO2"   = "SO2",
                             "mean_PM2_5" = "PM2.5")
  )

# Visualiser l'√©volution des polluants avec facettes
ggplot(yearly_pollutants_long, 
       aes(x = factor(year), y = mean_value, group = polluant, color = polluant)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  labs(title = "Trends in Pollutant Levels by Country",
       x = "Year",
       y = "Average Concentration (¬µg/m¬≥)",
       color = "Pollutants") +
  facet_wrap(~ country, ncol = 2) +
  theme_minimal(base_size = 10) +
  theme(plot.title = element_text(face = "bold", hjust = 0.5)) +
  scale_color_manual(values = c("NO2" = "blue", "PM10" = "red", "SO2" = "green", "PM2.5" = "purple"))


```


```{r}
# Agr√©ger l'AQI par ann√©e (par exemple, en calculant l'AQI moyen)
yearly_aqi <- data %>% 
  group_by(year) %>% 
  summarize(mean_AQI = mean(AQI, na.rm = TRUE))

# Cr√©er le graphique en barres avec de l'espace entre les barres
ggplot(yearly_aqi, aes(x = factor(year), y = mean_AQI)) +
  geom_bar(stat = "identity", width = 0.7, fill = viridis(1), color = "black") +
  labs(title = "Evolution of AQI in Europe",
       x = "Year",
       y = "Average AQI") +
  theme_minimal(base_size = 14) +
  theme(plot.title = element_text(face = "bold", hjust = 0.5))

```
```{r}
# Filtrer pour les pays d'int√©r√™t (France, Allemagne, Royaume-Uni, Suisse)
# Assumons que les codes ISO sont "FR", "DE", "GB" et "CH"
countries_interest <- c("FR", "DE", "GB", "CH")
data_filtered <- data %>% filter(country %in% countries_interest)

# Agr√©ger l'AQI par ann√©e pour chaque pays
yearly_aqi <- data_filtered %>%
  group_by(country, year) %>%
  summarize(mean_AQI = mean(AQI, na.rm = TRUE)) %>%
  ungroup()

# Cr√©er un graphique en barres avec facettes (une facette par pays)
ggplot(yearly_aqi, aes(x = factor(year), y = mean_AQI, fill = country)) +
  geom_bar(stat = "identity", width = 0.7, color = "black") +
  scale_fill_viridis_d(option = "magma") +
  labs(title = "Trends in AQI for France, Germany, UK, and Switzerland",
       x = "Year",
       y = "Average AQI") +
  facet_wrap(~ country, ncol = 2) +
  theme_minimal(base_size = 12) +
  theme(plot.title = element_text(face = "bold", hjust = 0.5),
        legend.position = "none")

```
```{r}
library(dplyr)
library(lubridate)

# S√©lectionner uniquement les 4 pays
countries_interest <- c("FR", "DE", "CH", "GB")  # Codes ISO
data_filtered <- data %>%
  filter(country %in% countries_interest) %>%
  mutate(month = month(date, label = TRUE),  # Extraire le mois
         year = year(date))  # Extraire l'ann√©e

```


```{r}
library(ggplot2)

# Calculate monthly average AQI per country
monthly_avg <- data_filtered %>%
  group_by(country, month) %>%
  summarize(mean_AQI = mean(AQI, na.rm = TRUE))

# Seasonality plot
ggplot(monthly_avg, aes(x = month, y = mean_AQI, group = country, color = country)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  labs(title = "AQI Seasonality ",
       x = "Month",
       y = "Average AQI",
       color = "Country") +
  theme_minimal() +
  scale_x_discrete(labels = month.abb)  # Display abbreviated month names


```


```{r}
library(forecast)

# Boucle pour d√©composer l'AQI de chaque pays
for (ctry in countries_interest) {
  print(paste("D√©composition STL pour", ctry))
  
  # Filtrer les donn√©es par pays
  country_data <- data_filtered %>%
    filter(country == ctry) %>%
    arrange(date)
  
  # Convertir en s√©rie temporelle (fr√©quence 12 car donn√©es mensuelles)
  ts_data <- ts(country_data$AQI, start = c(min(country_data$year)), frequency = 12)
  
  # Appliquer la d√©composition STL
  decomposed <- stl(ts_data, s.window = "periodic")
  
  # Afficher la d√©composition
  plot(decomposed, main = paste("D√©composition STL -", ctry))
}

```

```{r}
library(dplyr)
library(ggplot2)
library(lubridate)

# Ajouter une colonne mois et ann√©e
data <- data %>%
  mutate(month = month(date, label = TRUE),  # Extrait le mois sous forme de facteur (Jan, Feb, ...)
         year = year(date))  # Extrait l'ann√©e

# Calculer la moyenne mensuelle des polluants
monthly_avg <- data %>%
  group_by(month) %>%
  summarize(mean_AQI = mean(AQI, na.rm = TRUE),
            mean_NO2 = mean(NO2, na.rm = TRUE),
            mean_PM10 = mean(PM10, na.rm = TRUE),
            mean_PM2_5 = mean(PM2_5, na.rm = TRUE),
            mean_SO2 = mean(SO2, na.rm = TRUE))

# Visualiser la saisonnalit√© avec ggplot
ggplot(monthly_avg, aes(x = month)) +
  geom_line(aes(y = mean_AQI, group = 1, color = "AQI"), size = 1.2) +
  geom_line(aes(y = mean_NO2, group = 1, color = "NO2"), size = 1.2) +
  geom_line(aes(y = mean_PM10, group = 1, color = "PM10"), size = 1.2) +
  geom_line(aes(y = mean_PM2_5, group = 1, color = "PM2.5"), size = 1.2) +
  geom_line(aes(y = mean_SO2, group = 1, color = "SO2"), size = 1.2) +
  labs(title = "Saisonnalit√© des Polluants Atmosph√©riques",
       x = "Mois",
       y = "Concentration Moyenne (¬µg/m¬≥)",
       color = "Polluant") +
  theme_minimal() +
  scale_color_manual(values = c("AQI" = "black", "NO2" = "blue", "PM10" = "red", "PM2.5" = "purple", "SO2" = "green"))

```
```{r}
library(forecast)

# Conversion en s√©rie temporelle (fr√©quence = 12 car donn√©es mensuelles)
data_ts <- ts(data$AQI, start = c(min(data$year)), frequency = 12)

# D√©composer la s√©rie
decomposed_ts <- stl(data_ts, s.window = "periodic")

# Afficher la d√©composition
plot(decomposed_ts)

```
```{r}
kruskal.test(AQI ~ month, data = data)

```
```{r}
par(mfrow=c(2,2))  # Afficher 4 graphiques (1 par pays)

# Boucle pour tracer les ACF de chaque pays
for (ctry in countries_interest) {
  country_data <- data_filtered %>%
    filter(country == ctry) %>%
    arrange(date)
  
  # V√©rifier qu'il y a assez de donn√©es
  if (nrow(country_data) > 12) {
    acf(country_data$AQI, main = paste("Autocorrelation AQI -", ctry))
  } else {
    print(paste("Pas assez de donn√©es pour", ctry))
  }
}


```
```{r}
library(tseries)
adf.test(data$AQI, alternative = "stationary")

```
Si p > 0.05, la s√©rie n'est pas stationnaire et contient une tendance √† long terme.




```{r}
# Cr√©er des intervalles (bins) pour l'AQI ; ajustez la largeur des bins selon vos besoins
data <- data %>%
  mutate(AQI_bin = cut(AQI, breaks = seq(0, max(AQI, na.rm = TRUE), by = 5), 
                       include.lowest = TRUE, right = FALSE))

# Cr√©er le tableau de fr√©quences
table_AQI <- table(data$AQI_bin)
print(table_AQI)
```

```{r}
# Calcul du binwidth en utilisant les min et max de AQI et en divisant par 20 bins
bin_width <- (max(data$AQI, na.rm = TRUE) - min(data$AQI, na.rm = TRUE)) / 20

# Cr√©ation de l'histogramme avec des espaces entre les barres
ggplot(data, aes(x = AQI)) +
  geom_histogram(aes(fill = ..count..), 
                 binwidth = bin_width, 
                 width = bin_width * 0.9,  # 90% of the width, so 10% spacing
                 color = "black", 
                 alpha = 0.9) +
  scale_fill_viridis_c(option = "magma") +
  labs(title = "Histogram of AQI",
       x = "AQI",
       y = "Frequency") +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title = element_text(face = "bold"),
    legend.position = "none"
  )

```
```{r}
ggplot(data, aes(y = AQI)) +
  geom_boxplot(fill = "cyan", alpha = 0.5) +
  labs(title = "Boxplot of AQI", y = "AQI Index") +
  theme_minimal()

```


```{r}
# Charger les biblioth√®ques n√©cessaires
library(dplyr)
library(ggplot2)

# Calcul du binwidth pour une meilleure visualisation
bin_width <- (max(data$error, na.rm = TRUE) - min(data$error, na.rm = TRUE)) / 20

# Cr√©ation de l'histogramme
ggplot(data, aes(x = error)) +
  geom_histogram(aes(fill = ..count..), 
                 binwidth = bin_width, 
                 width = bin_width * 0.9,  # 90% de la largeur pour un l√©ger espacement
                 color = "black", 
                 alpha = 0.9) +
  scale_fill_viridis_c(option = "magma") +
  labs(title = "Histogramme de l'Erreur de Pr√©vision",
       x = "Erreur de pr√©vision",
       y = "Fr√©quence") +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title = element_text(face = "bold"),
    legend.position = "none"
  )

```

```{r}
# Charger les biblioth√®ques n√©cessaires
library(dplyr)
library(ggplot2)

# Appliquer la transformation logarithmique (ajout de 1 pour √©viter log(0))
data <- data %>%
  mutate(log_error = log(error + 1))

# Calcul du binwidth pour une meilleure visualisation
bin_width <- (max(data$log_error, na.rm = TRUE) - min(data$log_error, na.rm = TRUE)) / 20

# Cr√©ation de l'histogramme
ggplot(data, aes(x = log_error)) +
  geom_histogram(aes(fill = ..count..), 
                 binwidth = bin_width, 
                 width = bin_width * 0.9,  # 90% de la largeur pour un l√©ger espacement
                 color = "black", 
                 alpha = 0.9) +
  scale_fill_viridis_c(option = "magma") +
  labs(title = "Histogram of Forecast error ",
       x = "Log( Error)",
       y = "Frequency") +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title = element_text(face = "bold"),
    legend.position = "none"
  )


```

```{r}
# Charger ggplot2
library(ggplot2)

# Calcul du binwidth pour PM2.5 (20 bins)
bin_width_pm25 <- (max(data$PM2_5, na.rm = TRUE) - min(data$PM2_5, na.rm = TRUE)) / 20

# Cr√©ation de l'histogramme de PM2.5 avec des espaces entre les barres
ggplot(data, aes(x = PM2_5)) +
  geom_histogram(aes(fill = ..count..), 
                 binwidth = bin_width_pm25, 
                 width = bin_width_pm25 * 0.9,  # 90% de la largeur, donc 10% d'espace
                 color = "black", 
                 alpha = 0.9) +
  scale_fill_viridis_c(option = "magma") +
  labs(title = "Histogram of PM2.5",
       x = "PM2.5 (¬µg/m¬≥)",
       y = "Frequency") +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title = element_text(face = "bold"),
    legend.position = "none"
  )

```
```{r}
# Cr√©ation de la courbe de densit√© pour PM2.5
ggplot(data, aes(x = PM2_5)) +
  geom_density(fill = "blue", alpha = 0.4, color = "black", size = 1) +
  labs(title = "Courbe de Densit√© de PM2.5",
       x = "PM2.5 (¬µg/m¬≥)",
       y = "Densit√©") +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title = element_text(face = "bold")
  )
```
```{r}
# Charger ggplot2
library(ggplot2)

# Calcul du binwidth pour PM2.5 (20 bins)
bin_width_pm25 <- (max(data$PM2_5, na.rm = TRUE) - min(data$PM2_5, na.rm = TRUE)) / 20

# Cr√©ation de l'histogramme avec superposition de la courbe de densit√©
ggplot(data, aes(x = PM2_5)) +
  geom_histogram(aes(y = ..density..), 
                 binwidth = bin_width_pm25, 
                 fill = "lightblue", 
                 color = "black", 
                 alpha = 0.6) +  # Histogram
  geom_density(color = "red", size = 1.2) +  # Density curve
  labs(title = "Histogram and Density of PM2.5",
       x = "PM2.5 (¬µg/m¬≥)",
       y = "Density") +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title = element_text(face = "bold")
  )

```
```{r}
# Calcul du binwidth pour AQI (20 bins)
bin_width_aqi <- (max(data$AQI, na.rm = TRUE) - min(data$AQI, na.rm = TRUE)) / 20

# Cr√©ation de l'histogramme avec superposition de la courbe de densit√©
ggplot(data, aes(x = AQI)) +
  geom_histogram(aes(y = ..density..), 
                 binwidth = bin_width_aqi, 
                 fill = "lightblue", 
                 color = "black", 
                 alpha = 0.6) +  # Histogram
  geom_density(color = "red", size = 1.2) +  # Density curve
  labs(title = "Histogram and Density of AQI",
       x = "AQI Index",
       y = "Density") +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title = element_text(face = "bold")
  )

```


```{r}
# Charger les biblioth√®ques n√©cessaires
library(corrplot)
library(knitr)
library(kableExtra)

# S√©lectionner uniquement les variables num√©riques
cor_matrix <- cor(data[, c("error", "AQI", "NO2", "PM10", "PM2_5", "SO2", "gdp", "inflation_rate", "unemployment_rate")], 
                  use = "complete.obs")

# Affichage graphique de la matrice de corr√©lation
corrplot(cor_matrix, method = "color", type = "lower", tl.col = "black", tl.srt = 45)

# Transformer la matrice en un tableau structur√©
cor_table <- as.data.frame(as.table(cor_matrix))

# Renommer les colonnes pour plus de clart√©
colnames(cor_table) <- c("Variable 1", "Variable 2", "Corr√©lation")

# Filtrer pour √©viter les doublons et rendre la lecture plus facile
cor_table <- cor_table[cor_table$`Variable 1` != cor_table$`Variable 2`, ]

# Trier par valeur absolue de la corr√©lation (de la plus forte √† la plus faible)
cor_table <- cor_table[order(abs(cor_table$Corr√©lation), decreasing = TRUE), ]

# Affichage sous forme de tableau structur√©
cor_table %>%
  kable("html", caption = "Matrice de Corr√©lation Structur√©e") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))


```
#Si une corr√©lation est > 0.5 ou < -0.5, il y a une relation notable.
#Une forte colin√©arit√© entre plusieurs polluants pourrait fausser les r√©sultats.

```{r}
# Charger les biblioth√®ques n√©cessaires
library(dplyr)
library(reshape2)
library(knitr)
library(kableExtra)
library(openxlsx)  # Pour exporter en Excel

# Ajouter le terme quadratique AQI_squared
data <- data %>%
  mutate(AQI_squared = AQI^2)

# Calculer la matrice de corr√©lation
cor_matrix <- cor(data[, c("error", "AQI", "AQI_squared")], use = "complete.obs")

# Transformer la matrice en format tableau crois√© (data frame)
cor_table <- as.data.frame(as.table(cor_matrix))

# Renommer les colonnes pour plus de clart√©
colnames(cor_table) <- c("Variable 1", "Variable 2", "Corr√©lation")

# Affichage structur√© sous forme de tableau crois√©
kable(cor_table, caption = "Matrice de Corr√©lation Crois√©e") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

# Exporter en fichier Excel
write.xlsx(cor_table, file = "Matrice_Correlation_Crois√©e.xlsx", sheetName = "Corr√©lation", rowNames = FALSE)

# Message de confirmation
cat("‚úÖ La matrice de corr√©lation crois√©e a √©t√© export√©e sous le nom 'Matrice_Correlation_Crois√©e.xlsx' üìÇ")

```


```{r}
ggplot(data, aes(x = country, y = log_error, fill = country)) +
  geom_boxplot() +
  labs(title = "Comparison of Forecast Errors by Country", 
       x = "Country", 
       y = "Log(Forecast Error)") +
  theme_minimal()



```
```{r}
# Charger les biblioth√®ques
library(ggplot2)
library(dplyr)

# Appliquer une transformation logarithmique pour √©viter l'effet "tout concentr√© autour de z√©ro"
data <- data %>%
  mutate(log_error = log(1 + abs(error)))  # Ajout d'une transformation log(1 + error) pour lisibilit√©

# S√©lection des analystes avec le plus d'observations (Top 20)
top_analysts <- data %>%
  group_by(id_analyst) %>%
  summarise(Nb_Obs = n(), Mean_Error = mean(error, na.rm = TRUE)) %>%
  arrange(desc(Nb_Obs)) %>%
  top_n(20, Nb_Obs)  # Prendre les 20 analystes les plus fr√©quents

data_filtered <- data %>% filter(id_analyst %in% top_analysts$id_analyst)

# Cr√©ation du boxplot am√©lior√© avec transformation log
ggplot(data_filtered, aes(x = as.factor(id_analyst), y = log_error, fill = as.factor(id_analyst))) +
  geom_boxplot(outlier.shape = NA, alpha = 0.6) +  # Suppression des outliers visibles
  geom_jitter(width = 0.2, alpha = 0.2, color = "black", size = 1) +  # Points plus petits et transparents
  labs(title = "Distribution Log des Erreurs de Pr√©vision par Analyste (Top 20)",
       x = "ID Analyste (Top 20)",
       y = "log(1 + |Erreur de pr√©vision|)") +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),  # Rotation des labels pour lisibilit√©
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title = element_text(face = "bold"),
    legend.position = "none"
  )


```
#√©tant donn√© que l'erreur de pr√©vision est fortement concentr√©e autour de z√©ro, nous pouvons am√©liorer encore plus la visualisation en transformant error pour mieux voir les variations. donc en log  Supprimer les analystes ayant des erreurs trop faibles uniquement ‚Üí Garde seulement les analystes avec un minimum de variabilit√©.
```{r}
# Moyenne des erreurs par ann√©e
data_summary_time <- data %>%
  group_by(year) %>%
  summarise(Moyenne_Error = mean(error, na.rm = TRUE))

# Trac√© de la tendance des erreurs dans le temps
ggplot(data_summary_time, aes(x = year, y = Moyenne_Error)) +
  geom_line(color = "blue", size = 1) +
  geom_point(color = "red", size = 2) +
  labs(title = "√âvolution des Erreurs de Pr√©vision au Fil du Temps",
       x = "Ann√©e",
       y = "Erreur Moyenne") +
  theme_minimal()

```

```{r}
ggplot(data, aes(x = PM2_5, y = error)) +
  geom_point(alpha = 0.5, color = "blue") +
  geom_smooth(method = "loess", color = "red", se = TRUE) +  # LOESS capture non-lin√©arit√©s
  labs(title = "Relation non lin√©aire entre PM2.5 et Erreur",
       x = "PM2.5 (Œºg/m¬≥)",
       y = "performance de l'analyste") +
  theme_minimal()

```

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# 1. Aggregated stats
yearly_stats <- data %>%
  group_by(year) %>%
  summarize(mean_AQI = mean(AQI, na.rm = TRUE),
            mean_error = mean(error, na.rm = TRUE))

# 2. Plot with dual Y axis
ggplot(yearly_stats, aes(x = as.numeric(year))) +
  
  # Primary axis: AQI
  geom_line(aes(y = mean_AQI, color = "AQI"), size = 1.2) +
  geom_point(aes(y = mean_AQI, color = "AQI"), size = 2) +
  
  # Secondary axis: Error (rescaled to fit the same plot)
  geom_line(aes(y = mean_error * 10, color = " Error"), size = 1.2, linetype = "dashed") +
  geom_point(aes(y = mean_error * 10, color = "SError"), size = 2, shape = 17) +
  
  # Define axis labels and scaling
  scale_y_continuous(
    name = "Average AQI",
    sec.axis = sec_axis(~./10, name = "Average Error")
  ) +
  
  scale_x_continuous(breaks = seq(2015, 2023, 1)) +
  
  scale_color_manual(values = c("AQI" = "darkorange", "Error" = "steelblue")) +
  
  labs(title = "Trends in Air Pollution and Analyst Error",
       x = "Year",
       color = "Indicator") +
  
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title.y.right = element_text(color = "steelblue"),
    axis.title.y.left  = element_text(color = "darkorange")
  )

```
#Si l‚Äôerreur de pr√©vision augmente ou diminue avec le temps, il faudra int√©grer une tendance temporelle dans le mod√®le. Des variations cycliques ? ‚Üí Il faut peut-√™tre inclure des effets de saisonnalit√© (mois, trimestre).

```{r}
# Charger les biblioth√®ques n√©cessaires
library(corrplot)
library(dplyr)
library(openxlsx)  # Pour exporter en Excel

# V√©rifier que les donn√©es sont bien tri√©es par date et analyste
data <- data %>%
  arrange(id_analyst, date) %>%  # Tri pour le bon calcul des lags
  mutate(
    error_lag1 = lag(error, 1), 
    AQI_lag1 = lag(AQI, 1),
    PM2_5_lag1 = lag(PM2_5, 1),
    gdp_lag1 = lag(gdp, 1)
  )

# S√©lectionner uniquement les variables cl√©s
cor_matrix <- cor(data[, c("error", "log_error", "AQI", "PM2_5", "PM2_5_lag1", "gdp")], use = "complete.obs")

# Affichage graphique
corrplot(cor_matrix, method = "color", type = "lower", tl.col = "black", tl.srt = 45)

# Convertir la matrice en tableau structur√©
cor_table <- as.data.frame(cor_matrix)

# Exporter en fichier Excel
write.xlsx(cor_table, file = "Matrice_Correlation_Lags.xlsx", sheetName = "Corr√©lation", rowNames = TRUE)

# Message de confirmation
cat("‚úÖ La matrice de corr√©lation avec variables retard√©es a √©t√© export√©e sous le nom 'Matrice_Correlation_Lags.xlsx' üìÇ")


```
#Si error est fortement corr√©l√© √† error_lag1, il faudra utiliser un mod√®le dynamique (ex : Arellano-Bond GMM).Si la pollution actuelle est tr√®s corr√©l√©e aux valeurs retard√©es, alors la pollution persistante peut √™tre un facteur cl√©.

```{r}
library(ggplot2)

ggplot(data, aes(x = AQI, y = log_error)) +
  geom_point(alpha = 0.4, color = "blue") +
  geom_smooth(method = "loess", color = "red", se = TRUE) +
  labs(title = "Relationship Between AQI and Analysts' Forecast Error",
       x = "AQI",
       y = "log(Forecast Error)") +
  theme_minimal()



```
```{r}
# Charger les biblioth√®ques n√©cessaires
library(dplyr)
library(openxlsx)  # Pour exporter en Excel

# Ajouter le terme quadratique et son logarithme
data <- data %>%
  mutate(AQI_squared = AQI^2,
         log_AQI_squared = log(AQI_squared + 1),  # Ajout de 1 pour √©viter les valeurs n√©gatives
         log_AQI = log(AQI + 1), 
         log_error = log(abs(error) + 1))  # Log de l'erreur en valeur absolue pour √©viter les valeurs n√©gatives

# S√©lectionner les variables d'int√©r√™t
variables <- c("log_error", "log_AQI", "log_AQI_squared")

# Calculer la matrice de corr√©lation
cor_matrix <- cor(data[, variables], use = "complete.obs")

# Convertir la matrice en data frame pour l'export
cor_df <- as.data.frame(cor_matrix)

# Exporter en fichier Excel
write.xlsx(cor_df, file = "Matrice_Correlation_Log.xlsx", sheetName = "Corr√©lation", rowNames = TRUE)

# Message de confirmation
cat("‚úÖ La matrice de corr√©lation a √©t√© export√©e sous le nom 'Matrice_Correlation_Log.xlsx' üìÇ")

```


```{r}
# Exporter les r√©sultats sous forme de tableau lisible
stargazer(model_quadratic, type = "text",
          title = "Estimation du Mod√®le Quadratique sur l'Erreur des Analystes",
          digits = 4)

```
  
```{r}
# Estimation du mod√®le quadratique avec effets fixes
model_quadratic <- plm(error ~ AQI + AQI_squared + gdp + inflation_rate + unemployment_rate, 
                        data = data, 
                        model = "within", 
                        index = c("id_analyst", "year"))

# Affichage des r√©sultats
summary(model_quadratic)

```
```{r}
data <- data %>%
  mutate(AQI_lag1 = lag(AQI, 1),
         AQI_lag7 = lag(AQI, 7),
         AQI_lag14 = lag(AQI, 14))

cor_matrix <- cor(data[, c("error", "AQI_squared", "AQI_lag7", "AQI_lag14")], use = "complete.obs")
print(cor_matrix)

```

```{r}
# Cr√©er des cat√©gories de pollution bas√©es sur les quartiles
data <- data %>%
  mutate(pollution_level = cut(AQI,
                               breaks = quantile(AQI, probs = c(0, 0.25, 0.50, 0.75, 1), na.rm = TRUE),
                               labels = c("Low", "Moderate", "High", "Very High"),
                               include.lowest = TRUE),
         log_error = log(error + 1))  # Transformation logarithmique de l'erreur

# Visualisation de la distribution des erreurs de pr√©vision par niveau de pollution (Boxplot)
ggplot(data, aes(x = pollution_level, y = log_error, fill = pollution_level)) +
  geom_boxplot(alpha = 0.7, outlier.color = "red", outlier.shape = 16, outlier.size = 2) +
  scale_fill_viridis_d() +
  labs(title = "Forecast Errors by Pollution Levels",
       x = "Pollution Level",
       y = "Log(Forecast Error)",
       fill = "Pollution Level") +
  theme_minimal(base_size = 14) +
  theme(plot.title = element_text(face = "bold", hjust = 0.5)) 

```
```{r}
install.packages("tseries")
```


```{r}
library(tseries)

# Test ADF sur l'erreur de pr√©vision
adf.test(data$error, alternative = "stationary")

# Test ADF sur AQI
adf.test(data$AQI, alternative = "stationary")

```
#Si p-value < 0.05 ‚Üí La variable est stationnaire ‚úÖ.#i p-value > 0.05 ‚Üí La variable n'est pas stationnaire, il faut prendre la diff√©rence premi√®re (diff(error)).

```{r}
# Charger les biblioth√®ques n√©cessaires
library(tseries)
library(dplyr)
library(knitr)
library(kableExtra)

# Liste des variables √† tester
variables <- c("error", "AQI", "PM2_5", "gdp")

# Cr√©ation d'un tableau vide pour stocker les r√©sultats
results <- data.frame(Variable = character(),
                      P_Value = numeric(),
                      Stationnaire = character(),
                      stringsAsFactors = FALSE)

# Boucle sur chaque variable pour effectuer le test ADF
for (var in variables) {
  test_result <- adf.test(data[[var]], alternative = "stationary")
  p_value <- test_result$p.value
  conclusion <- ifelse(p_value < 0.05, "‚úÖ Stationnaire", "‚ùå Non stationnaire (Diff n√©cessaire)")
  
  # Ajouter les r√©sultats au tableau
  results <- rbind(results, data.frame(Variable = var, P_Value = round(p_value, 4), Stationnaire = conclusion))
}

# Affichage du tableau sous format propre
results %>%
  kable("html", caption = "R√©sultats du Test de Stationnarit√© (ADF)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

```
#Test de Dickey-Fuller Augment√© (ADF)
```{r}
# Charger les biblioth√®ques n√©cessaires
library(plm)
library(lmtest)

# Mod√®le √† effets fixes (FE) sans les variables retard√©es, week et 2weeks
model_fe <- plm(error ~ AQI + NO2 + PM10 + PM2_5 + SO2 + 
                gdp + inflation_rate + unemployment_rate, 
                data = data, 
                model = "within", 
                index = c("id_analyst", "year"))

# Mod√®le √† effets al√©atoires (RE) sans les variables retard√©es, week et 2weeks
model_re <- plm(error ~ AQI + NO2 + PM10 + PM2_5 + SO2 + 
                gdp + inflation_rate + unemployment_rate, 
                data = data, 
                model = "random", 
                index = c("id_analyst", "year"))

# Test de Hausman
hausman_test <- phtest(model_fe, model_re)
print(hausman_test)



```
#Si p-value < 0.05 ‚Üí Utiliser Effets Fixes (FE) ‚úÖ Cela signifie que les effets individuels (id_analyst) sont corr√©l√©s aux variables explicatives.Le mod√®le RE est biais√©, donc il faut utiliser FE.

#Si p-value > 0.05 ‚Üí Utiliser Effets Al√©atoires (RE) ‚úÖ Cela signifie que les effets individuels ne sont pas corr√©l√©s aux variables explicatives. Le mod√®le RE est plus efficace et √©conomiquement justifi√©.
```{r}
# Comparer R¬≤ ajust√© des deux mod√®les
cat("R¬≤ ajust√© FE:", summary(model_fe)$r.squared.adj, "\n")
cat("R¬≤ ajust√© RE:", summary(model_re)$r.squared.adj, "\n")
```

```{r}
library(splines)
# R√©gression avec splines naturelles
model_spline <- lm(error ~ ns(AQI, df = 4), data = data)

# R√©sum√© des r√©sultats
summary(model_spline)

# Visualisation
ggplot(data, aes(x = AQI, y = error)) +
  geom_point(alpha = 0.5, color = "blue") +
  geom_smooth(method = "lm", formula = y ~ ns(x, df = 4), color = "red", se = TRUE) +
  labs(title = "R√©gression avec Splines : AQI vs Erreur",
       x = "Indice AQI",
       y = "Erreur de pr√©vision") +
  theme_minimal()
```

#Tester une relation non lin√©aire
```{r}
data <- data %>%
  mutate(AQI_squared = AQI^2)

model_fe_quad <- plm(error ~ AQI + AQI_squared + gdp + inflation_rate + unemployment_rate, 
                      data = data, 
                      model = "within", 
                      index = c("id_analyst", "year"))
summary(model_fe_quad)


```
```{r}
AQI_max <- -1.2133 / (2 * -0.0241)
print(AQI_max)

```

```{r}
model_fe_country <- plm(error ~ AQI + AQI_squared + gdp + inflation_rate + unemployment_rate, 
                         data = data, model = "within", index = c("country", "year"))
summary(model_fe_country)

```

```{r}

```


## R Markdown
This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
